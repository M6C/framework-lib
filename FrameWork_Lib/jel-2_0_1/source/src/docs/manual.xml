<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
 "/usr/share/sgml/docbook/sgml-dtd-4.1.2/docbookx.dtd">
<book>
<title>Java Expressions Library</title>

<chapter>
  <title>About this manual</title>
  <para>This manual is mostly examples-based. It starts with two
  simple step-by-step examples (showing how to deal with static and
  dynamic libraries), which should give enough information for basic
  JEL usage (but don't forget to read the rest of this manual to learn
  how to get the top performance from JEL). The additional information
  can be found in <ulink url="javadoc/index.html">API
  documentation</ulink>.</para>
</chapter>

<chapter>
  <title>JEL design goals</title>
  <para>The main design goal was to create light weight expression compiler
generating extremely fast code. The main emphasis is the code
execution time and not the compilation time (it is nevertheless
small). The other goal was to make JEL language to be very close to
Java language with direct access to all built-in Java data types and
functions.</para>
</chapter>

<chapter>
  <title>Features</title>
  <itemizedlist>
    <listitem><para>Support for all Java data types (boolean, byte,
    char, short, long, int, float, double, arrays,
    references)</para></listitem>
    <listitem><para>Octal (0456) and hexadecimal (0x1FFF)
    literals.</para></listitem>
    <listitem><para>Support for all Java arithmetic operators: +
    (add),- (subtract), * (multiply), / (divide), % (remainder), &amp;
    (bitwise and),| (bitwise or), ^ (bitwise xor),~ (bitwise
    complement), &lt;&lt; (left shift), &gt;&gt; (right signed shift),
    &gt;&gt;&gt; (right unsigned shift); on most of supported data
    types according to Java Language Specification
    (JLS)</para></listitem>
    <listitem><para>Comparison operators (==,!=,&lt;,&gt;=,&gt;,&lt;=)
    as defined by JLS.</para></listitem>
    <listitem><para>dot (&quot;.&quot;) operator on objects
    (&quot;abc&quot;.length()==3).</para></listitem>
    <listitem><para>dot (&quot;.&quot;) operator on objects
    (&quot;abc&quot;.length()==3).</para></listitem>
    <listitem><para>Boolean logical operators (&amp;&amp;,||,!) with
    lazy evaluation (i.e. in the expression
    false&amp;&amp;complexBooleanFunction() the function is never
    called).</para></listitem>
    <listitem><para>Conditionals (true?2:3 = 2)</para></listitem>
    <listitem><para>Direct access to methods and fields of Java
    objects.</para></listitem>
    <listitem><para>Method overloading according to
    JLS.</para></listitem>
    <listitem><para>Dynamic variables interface allowing to add
    variables to JEL namespace without supplying the class file
    defining them.</para></listitem>
    <listitem><para>Automatic unwrapping of designated objects to Java
    primitive types.</para></listitem>
    <listitem><para>Support for strings. Objects of class
    java.lang.String can be directly entered into expressions using
    double quotes, also the standard Java escape codes are
    parsed. Example : "a string\n\015".</para></listitem>
    <listitem><para>String concatenation (&quot;a&quot;+2+(2>3)+object
    = &quot;a2false&quot;+object.toString()).</para></listitem>
    <listitem><para>User definable string comparison using usual
    relational operators &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;>&quot;,
    &quot;>=&quot;, &quot;==&quot;, &quot;!=&quot;, which employs
    locale by default.</para></listitem>
    <listitem><para>User-controllable object down-casting using
    &quot;(class.name)var&quot; syntax. It is possible to assign names
    to classes in JEL expressions to be different from their real Java
    class names.</para></listitem>
    <listitem><para>Constants folding, extended (by default, but can
    be controlled) to static methods (which are automatically called
    at compile time) and static fields (which are considered
    constants).</para></listitem>
    <listitem><para>High performance of generated code.</para></listitem>
  </itemizedlist>
</chapter>

<chapter>
  <title>How to use JEL.</title>
  <para>In this section a simple example of a program using JEL is
  given, and explained with references to more detailed sections of
  this manual. The example program evaluates the expression given on
  its command line (similar program exists in the distribution under
  the name <filename>./samples/Calculator.java</filename>), let's
  follow it step by step.</para>
  <programlisting>
    public static void main(String[] args) {
    
    // Assemble the expression
    StringBuffer expr_sb=new StringBuffer();
    for(int i=0;i&lt;args.length;i++) {
      expr_sb.append(args[i]);
      expr_sb.append(' ');
      };
    String expr=expr_sb.toString();
  </programlisting>
  <para>This first part of the program is not related to JEL. It's
  purpose is to assemble the expression, possibly, containing spaces
  into the single line. This has to be done, because shells tend to
  tokenize parameters but we don't need it here.
  <programlisting>    // Set up the library
    Class[] staticLib=new Class[1];
    try {
      staticLib[0]=Class.forName(&quot;java.lang.Math&quot;);
    } catch(ClassNotFoundException e) {
      // Can't be ;)) ...... in java ... ;)
    };
    Library lib=new Library(staticLib,null,null,null,null);
    try {
    lib.markStateDependent(&quot;random&quot;,null);
    } catch (NoSuchMethodException e) {
      // Can't be also
    };
  </programlisting>
  This piece of code establishes the namespace for use in JEL compiled
  expressions. The <classname>gnu.jel.Library</classname> object
  maintains this namespace.</para>
  
  <para>There can be two types of names in the Library :
  <emphasis>static</emphasis> and
  <emphasis>virtual</emphasis> (dynamic).</para>

  <para>Methods and variables of the first class are assumed (by
  default) to be dependent only on their arguments i.e. not to save
  any information from call to call (they are
  &quot;stateless&quot;)... Examples are mathematical functions like
  <function>sin</function>, <function>cos</function>,
  <function>log</function>, constants <constant>E</constant>,
  <constant>PI</constant> in <constant>java.lang.Math</constant>.  For
  such methods (fields) it does not matter how many times (when) they
  will be called (their value will be taken) the result will always be
  the same provided arguments (if they are present) are the
  same. Stateless methods will be evaluated by JEL at compile time if
  their arguments are constants (known at compile time). To define set
  of static functions(fields) it is needed to pass the array of Class
  objects, defining those functions, as the first parameter of the
  library constructor (see example above). Note ONLY STATIC functions
  of the Classes, passed in the first argument of the
  <classname>gnu.jel.Library</classname> constructor will be defined
  in the namespace. By default all static functions are considered
  &quot;stateless&quot; by JEL.</para>

  <para>However, some static functions still save their state (in
  static variables) in between calls. Thus they return different
  results, depending on when (how many times) they are is called even
  if their arguments are the same. If such function is evaluated at
  compile time, we have troubles, because it will be evaluated only
  once during expression lifetime and it's state dependence will be
  lost. Typical example of the static function, having a state is
  <function>java.lang.Math.random</function>. JEL has special
  mechanism, provided by <classname>gnu.jel.Library</classname> class
  to mark static functions as state dependent. (see the above example
  to find out how it was done for the
  <function>java.lang.Math.random</function>)</para>
  
  <para>The virtual functions, which are
  <emphasis>explicitly</emphasis> state dependent, will be discussed
  later in this document. The example we currently consider does not
  use them. However, virtual functions are, actually, most important
  to JEL because expression, containing all stateless functions, is a
  constant, it will be completely evaluated at compile time, there is
  absolutely no sense to evaluate such expression repeatedly (this is
  what JEL was designed for). Still we shall continue with this simple
  example as the following code is mostly independent of whether we
  use virtual functions or not...</para>
  <para><programlisting>    // Compile
    CompiledExpression expr_c=null;
    try {
      expr_c=Evaluator.compile(expr,lib);
    } catch (CompilationException ce) {
      System.err.print(&quot;&ndash;&ndash;&ndash;COMPILATION ERROR :&quot;);
      System.err.println(ce.getMessage());
      System.err.print(&quot;                       &quot;);
      System.err.println(expr);
      int column=ce.getColumn(); // Column, where error was found
      for(int i=0;i&lt;column+23-1;i++) System.err.print(' ');
      System.err.println('^');
    };</programlisting>

    This chunk of code is for the expression compilation. The crucial
    line is the call to <function>Evaluator.compile</function>, it is the
    point, where expression gets transformed into Java bytecode,
    loaded into the Java Virtual Machine using JEL ClassLoader and
    returned to caller as an instance of the subclass of
    <classname>gnu.jel.CompiledExpression</classname>.
    Typical user of JEL is not
    required to know what magic is going on inside of
    <function>Evaluator.compile(...)</function>. 
    Other code in this chunk is for
    the error reporting and will be discussed in the specialized
    section <link endterm="ERRORS" linkend="ERRORS"></link> below.
  </para>
  <para><programlisting>
      if (expr_c !=null) {
      
      // Evaluate (Can do it now any number of times FAST !!!)
      Number result=null;
      try {
	result=(Number)expr_c.evaluate(null);
      } catch (Throwable e) {
	System.err.println("Exception emerged from JEL compiled"+
			   " code (IT'S OK) :");
	System.err.print(e);
      };
  </programlisting>
  This code does the evaluation of the expression. It is done by
  calling the <function>evaluate</function> method of the JEL 
  compiled class, it is defined abstract in 
  <classname>gnu.jel.CompiledExpression</classname> but is
  redefined in the class compiled by JEL. The argument of this method
  is discussed in the section on virtual functions below. If only
  static functions are present in the library it is safe to pass the
  <constant>null</constant> pointer as the argument to 
  <function>evaluate</function>.
  </para>
  <para>Result of the <function>evaluate</function> method is always
  an object. JEL converts primitive numeric types into instances of
  corresponding Java reflection classes (read the section 
  <link endterm="FASTER" linkend="FASTER"></link>  to find out how to avoid
  this conversion). For example, a value of primitive type
  <type>long</type> will be returned as an instance of
  <classname>java.lang.Long</classname> class (<type>int</type> maps to
  <classname>java.lang.Integer</classname>, <type>float</type> to
  <classname>java.lang.Float</classname>, etc.). If result is an arbitrary Java
  object it is returned as the reference to that object.</para>
  
  <para>The <programlisting>try ... catch</programlisting> clause
  around the call to <function>evaluate</function> will be enforced by the Java
  compiler. It is required as errors can appear during evaluation. The
  general rule is: <emphasis>syntax, types incompatibility and function
  resolution errors will be reported at compile time (as thrown
  instance of <classname>gnu.jel.CompilationException</classname>),
  while the errors in the
  values of numbers will be reported at the execution
  time</emphasis>. For example expression "1/0" will generate no error
  at compile time (nevertheless it is the constant expression and its
  evaluation is attempted), but at the time of calling
  <function>execute</function>
  you will get a <classname>java.lang.ArithmeticError</classname> (division
  by zero) as it should be.</para>
  
  <para><programlisting>      // Print result
      if (result==null) 
	System.out.println("void");
      else
	System.out.println(result.toString());
   };
};</programlisting>
This last piece of code will print the result. And is concluding our
brief tour of the JEL usage.</para>
</chapter>
<chapter>
  <title id="LIBRARY">Using libraries</title>
  <para>The namespace of JEL expressions is represented by
<classname>gnu.jel.Library</classname> class. Its constructor:
<programlisting>Library(Class[]&nbsp;staticLib, Class[]&nbsp;dynamicLib,
Class[]&nbsp;dotClasses, DVMap&nbsp; resolver,
Hashtable&nbsp;cnmap)</programlisting>has five arguments. Their purposes are
following:<variablelist>
<varlistentry>
  <term>staticLib</term>
  <listitem><para>enumerates classes whose <emphasis>static</emphasis>
  methods are exported to JEL namespace and become usable from within
  expressions. Such methods do not require <varname>this</varname> pointer
  supplied to them at execution time.
  <link linkend="STATICLIB">More details</link></para></listitem>
</varlistentry>
<varlistentry>
  <term>dynamicLib</term>
  <listitem><para>enumerates classes whose <emphasis>virtual</emphasis> methods
  are exported. These methods require the references to the
  corresponding classes (<varname>this</varname> pointers) supplied to the
  expression at run-time. This is done using the <type>Class[]</type>>
  argument of <classname>CompiledExpression</classname>'s 
  <function>evaluate</function> method.
  <link linkend="VIRTUALLIB">More details</link></para></listitem>
</varlistentry>
<varlistentry>
  <term>dotClasses</term>
  <listitem><para>controls access for the dot (&quot;.&quot;)
  operator on classes.
  <link linkend="DOTOPER">More details</link></para></listitem>
</varlistentry>
<varlistentry>
  <term>resolver</term>
  <listitem><para>Dynamic variables interface. Allows to add new
  variables to the expressions names without supplying the class files
  defining them.  
  <link linkend="DYNVARS">More  details</link></para></listitem>
</varlistentry>
<varlistentry>
  <term>cnmap</term>
  <listitem><para>Maps the class names usable inside JEL expressions for
  non-primitive type casts into the Java classes
  <link linkend="OBJCASTS">More  details</link></para></listitem>
</varlistentry>
</variablelist></para>
<para>The details on usage of each of these arguments are given in a
separate sections below.</para>
<para>The working example using all current functionality of JEL
namespace is given in the 
<filename class="directory">examples/YourTestBed</filename> directory in
the distribution. You'll want to check it after reading this section.</para>
<section>
  <title id="STATICLIB">Exporting static methods of classes to JEL
  namespace.</title>
  <para>The array of references to classes 
  (<classname>java.lang.Class</classname>) whose public
  <emphasis>static</emphasis> methods and fields are to be exported should
  be passed as the first argument of the library constructor
  (<parameter>staticLib</parameter>). The public static fields and 
  methods of all these classes are merged together into the JEL namespace. The
  non-public or non-static members of <parameter>staticLib</parameter> classes
  are ignored.</para>
  <para>Methods overloading is supported and works also across classes
  (because the JEL namespace works similarly to the namespace defined
  in a single Java class). For example, if a class <classname>C1</classname>
  contains the method <function>public static C1.func(int)</function> 
  and a class <classname>C2</classname> contains the method 
  <function>public static C2.func(double)</function> and both these
  classes are passed as elements of the <parameter>staticLib</parameter>
  array. Then, the JEL expression <userinput>"func(1)"</userinput> calls 
  <function>C1.func(int)</function> and the expression
  <userinput>"func(1.0)"</userinput> calls 
  <function>C2.func(double)</function>. It also means
  that methods and fields of all classes supplied to the 
  <classname>Library</classname> are subject to the same constraints
  as members of a single Java class.</para>
  <para>Moreover, because JEL allows to call methods with no arguments
  omitting the empty brackets (that is <userinput>"func()"</userinput>
  and <userinput>"func"</userinput> are equivalent) there should be no
  fields and methods with no arguments having the same names in all
  classes presented to the <classname>Library</classname> constructor.</para>
  <para>To check whether the set of classes you gave to the library
  constructor satisfies all required constraints run your program
  against the debug version of JEL library
  (<filename>jel_g.jar</filename>).  Then, potential problems will be
  reported to you on the standard output.</para>
</section>
<section>
<title id="VIRTUALLIB">Exporting virtual methods of classes to JEL namespace.</title>
<para>The second argument of the library constructor
(<parameter>dynamicLib</parameter>) works similarly to the first one.
Except that only public <emphasis>virtual</emphasis> members are taken from
the listed classes. These members are merged into the namespace created from
classes from the <parameter>staticLib</parameter>. The rules for methods
overloading are the same as for classes listed in the first argument of library
constructor. Also, the overloading is working across the classes
listed in both first and second arguments of the Library constructor.</para>
<para>The crucial difference in the handling of classes listed in the
<parameter>dynamicLib</parameter> and the <parameter>staticLib</parameter>
comes from the fact that virtual members of <parameter>dynamicLib</parameter>
require <varname>this</varname> reference to the instance of the object of
their defining class be supplied at run-time. Thus, if 
<classname>C1</classname> contains the virtual method
<function>public func(double x)</function> its invocation actually requires
<emphasis>two</emphasis> arguments, one is <parameter>x</parameter> and the
other is the reference to the instance of class 
<classname>C1</classname>.</para>
<para>References to the instances of classes of the
<parameter>dynamicLib</parameter> array are supplied at the
execution time to the argument of the 
<function>evaluate(Object[]&nbsp;context)</function> method of
<classname>gnu.jel.CompiledExpression</classname>. 
The elements of the <parameter>context</parameter> array
should be instances of classes listed in <parameter>dynamicLib</parameter>
array at compile time and there should be one-to-one correspondence between
them. For example, if
<programlisting>dynamicLib[0]=com.mycompany.MyClass.class)</programlisting>,
the corresponding
entry in the context array, <parameter>context[0]</parameter>, 
must be a reference to
the <emphasis>instance</emphasis> of 
<classname>com.mycompany.MyClass</classname>.</para>

<para>Formally, for every <varname>i</varname>, it should be possible to cast 
the object in the <parameter>context[i]</parameter>
into the class, supplied in the <parameter>dynamicLib[i]</parameter> array
of the <classname>Library</classname> constructor, 
otherwise <classname>ClassCastException</classname> will be thrown from
<function>evaluate</function>.</para>

<para>Let's walk through the example, which calculates function of the
single variable many times and uses virtual method calls. This example
will consist of two classes : a user written class (providing access
to the variable) and the main class compiling and evaluating
expressions.  First start with the variable 
provider:<programlisting>public class VariableProvider {
  public double xvar;
  
  public double x() {return xvar;};
};</programlisting>
This class is trivial, it just defines the function, returning the
value of the variable <varname>x</varname>.</para>

<para>In the main class (see the first JEL example for headers) the code,
constructing the library will be replaced 
with:<programlisting>    // Set up library
    Class[] staticLib=new Class[1];
    try {
      staticLib[0]=Class.forName(&quot;java.lang.Math&quot;);
    } catch(ClassNotFoundException e) {
      // Can't be ;)) ...... in java ... ;)
    };

    Class[] dynamicLib=new Class[1];
    VariableProvider variables=new VariableProvider();
    Object[] context=new Object[1];
    context[0]=variables;
    dynamicLib[0]=variables.getClass();
    
    Library lib=new Library(staticLib,dynamicLib,null,null,null);
    try {
    lib.markStateDependent(&quot;random&quot;,null);
    } catch (NoSuchMethodException e) {
      // Can't be also
    };</programlisting>Absent in the static example, the additional code
    creates the <classname>VariableProvider</classname> and assigns its
    reference to an element of <parameter>context</parameter> array (to be
    passed to the <function>evaluate</function> method
    of the compiled expression). Also, now the 
    <parameter>dynamicLib</parameter> array as not null and contains
    the reference to the <classname>VariableProvider</classname> class.</para>

    <para>The code for compilation is exactly the same as in the example for
    static functions, except we have additional function <varname>x</varname>
    and the variable <varname>xvar</varname> defined for use inside the 
    compiled expressions. JEL has the special notation for the functions, 
    having no arguments, namely, brackets in <userinput>"x()"</userinput> 
    can be omitted to be "x". This allows to compile now ( with the above 
    defined library) the expressions like <userinput>"sin(x)"</userinput>,
    <userinput>"exp(x*x)"</userinput>, 
    <userinput>"pow(sin(x),2)+pow(cos(x),2)"</userinput>...</para>
    
    <para>The code for evaluation of an expression having virtual
    functions is replaced with:
    <programlisting>
      if (expr_c !=null) {
    
        try {
           for(int i=0;i&lt;100;i++) {
              variables.xvar=i;      // &lt;- Value of the variable
              System.out.println(expr_c.evaluate(context));
                               //^^^^^^^^^^^^^^^ evaluating 100 times
           };
        } catch (Throwable e) {
	   System.err.println("Exception emerged from JEL compiled"+
		              " code (IT'S OK) :");
           System.err.print(e);
        };
    };</programlisting>
    Note the two major differences: 1. we have explicitly 
    assigned the value to the variable; 2. the array of object references 
    (consisting of one element in this example) is passed to the 
    <function>evaluate</function> method. This piece of code will evaluate
    expressions for <varname>x=0..99</varname> with 
    step <constant>1</constant>.</para>
    <para>This concludes our dynamic library example. Try to modify the
    <filename>./Calculator.java</filename> sample yourself to allow 
    compilation of virtual functions as described above.</para>
</section>
<section>
  <title id="DOTOPER">Enabling the dot operator on objects.</title>
  <para>The third argument of <classname>gnu.jel.Library</classname>
  constructor enumerates classes which are available for dot operator
  within the expression. If this parameter is <constant>null</constant>
  JEL would not allow to use the dot operator at all. If it is an array
  of the length zero (e.g. <constant>new Class[0]</constant>) 
  JEL will open access to public methods
  of <emphasis>ALL</emphasis> objects encountered in the expression. From the
  security point of view allowing access to all objects can be
  dangerous, that is why there is a third case of non-zero length
  array explicitly enumerating classes allowing the dot operator on
  them.</para>
  <para>Once the dot operator is allowed on a class, it is possible to call
  all its public methods using the syntax
  <userinput>".method(arg1,arg2,...)"</userinput> in any context 
  where this class appears in an expression.</para>
</section>
<section>
  <title id="DYNVARS">Dynamic variables interface.</title>
  <para>All methods of exporting names into JEL namespace described up to
  this point relied on the Java class files for actual description of
  methods names and parameters. However, sometimes it is required to add
  a new variable to JEL namespace at run-time.</para>

  <para>One of the solutions would be to generate a new class file (e.g. using
  JEL) and supply it as a first or second argument of the library
  constructor. Unfortunately this can be quite cumbersome and time
  consuming.</para>

  <para>The other solution can be to define a family of methods in JEL 
  namespace <programlisting>YYY getXXXProperty(String name)</programlisting>for
  each possible variable types, where <classname>YYY</classname> is the class
  representing the property type and <classname>XXX</classname> is the name 
  of the type. Then, supposing we have methods
  <programlisting>  double getDoubleProperty(String name); // YYY=double XXX=Double
  String getStringProperty(String name); // YYY=java.lang.String XXX=String</programlisting>in the JEL namespace (either static or dynamic),
  the variables with arbitrary names can be entered into expression
  using the syntax<programlisting>getStringProperty(&quot;x&quot;) +
  (getDoubleProperty(&quot;y&quot;)+1.0)</programlisting></para>

  <para>This way has two drawbacks: 1) user has to remember the type of the
  variable (to call the appropriate <function>getXXX()</function> method); 
  2) a lot to type.</para>

  <para>Since the version 0.9.3 JEL provides the way to solve both
  these problems. To do that the fourth argument
  (<parameter>resolver</parameter>) of the library constructor is
  used. This argument supplies the reference to the subclass of
  <classname>gnu.jel.DVMap</classname>, and is used by JEL to resolve
  the dynamic variable names.  The <classname>gnu.jel.DVMap</classname>
  has an abstract method
  <programlisting>public String getTypeName(String  name)</programlisting>
  which returns XXX (see above) for a given  variable name, or null if no
  such variable is defined. Note that for resolver to work the family of
  methods
  <programlisting>YYY getXXXProperty(String name)</programlisting>
  must still be present in JEL namespace (e.g. as members of one of
  <parameter>dynamicLib[]</parameter> classes).</para>

  <para>Then, supposing<programlisting>resolver.getTypeName(&quot;x&quot;)==&quot;String&quot; &amp;&amp;
resolver.getTypeName(&quot;y&quot;)==&quot;Double&quot;</programlisting>
   the expression <userinput>"x+(y+1.0)"</userinput> will be automatically
   converted by JEL into
   <programlisting>getStringProperty(&quot;x&quot;)+(getDoubleProperty(&quot;y&quot;)+1.0)</programlisting>
   and compiled. Thus, user does not have to remember the variable types,
   typing is reduced and the existence of variables can be checked at the
  compile time.</para>

  <para>JEL also supports a hierarchical structure of variables. This means
  the dot (&quot;.&quot;) symbol can be present in the dynamic variable
  names. For example if
  <programlisting>resolver.getTypeName(&quot;x&quot;)!=null &amp;&amp; 
resolver.getTypeName(&quot;x.f1&quot;)==&quot;String&quot; &amp;&amp; 
resolver.getTypeName(&quot;x.f2&quot;)==&quot;Double&quot;</programlisting>
  the expression <userinput>&quot;x.f1+(x.f2+1.0)&quot;</userinput> will
  be compiled by JEL as
  <programlisting>getStringProperty(&quot;x.f1&quot;)+(getDoubleProperty(&quot;x.f2&quot;)+1.0)</programlisting>
  and (combined with dot operator) the expression 
  <userinput>&quot;x.f1.length()&quot;</userinput> will result in the length
  of the string <function>getString(&quot;x1.f1&quot;)</function>.</para>

  <para>Notice in the last example that if one wants to have defined
  the dynamic variable <userinput>&quot;x.y&quot;</userinput> the variable
  <userinput>&quot;x&quot;</userinput> must
  also be the dynamic variable
  (<constant>resolver.getTypeName(&quot;x&quot;)!=null</constant>).</para>

  <para>If there is conflict between the dynamic variable name and other
  name in JEL namespace the dynamic variable has a priority.</para>

  <para>Since JEL 0.9.9 it is possible to translate the names of dynamic
  variables from strings into the constants of Java primitive
  types. This is done using non-identity <function>DVMap.translate</function>
  method. The translation helps to improve performance in some cases.</para>

  <para>Consider the following example. Suppose the underlying storage for
  dynamic variables is an array (or <classname>Vector</classname>), so that
  the value of the variable can be obtained by an integer index into that 
  array (like numbered columns in a spreadsheet). Next, assume you still
  want to refer to the variables by names (e.g. you allowed user to assign 
  names to the columns). Now, if the first column is named 
  <userinput>&quot;x&quot;</userinput> and
  is of Double type, an expression <userinput>&quot;x&quot;</userinput>,
  using dynamic variables interface with identity translation will be
  compiled into <userinput>getDoubleProperty(&quot;x&quot;)</userinput>.
  It means the translation of
  the string <userinput>&quot;x&quot;</userinput> into the column number
  <constant>1</constant> will have to be
  performed at run-time each time the expression is
  evaluated. Considering that Java strings are immutable, this may incur
  a substantial performance penalty.</para>

  <para>The performance can be improved if the <function>translate</function>
  method of <classname>DVMap</classname> is overridden by the following:
  <programlisting>public Object translate(String name) {
   if (name.equals(&quot;x&quot;)) return new Integer(1);
   return name;
   };</programlisting>
   This is already a non-identity translation. With such
   <classname>DVMap</classname> the expression &quot;x&quot; will be
   compiled by JEL into <userinput>getDoubleProperty(1)</userinput>, 
   note that it is
   <function>getDoubleProperty(int)</function> method, which is called.
   This way the mapping of the variable name into the variable index is
   performed at compile-time, while at run-time the index is readily available.
   By defining the appropriate translations the dynamic variable lookup can
   be split in a user-controlled way between the expression compilation
  and execution stages to achieve the best performance.</para>

  <para>The <function>translate</function> method is allowed to return
  only instances of Java reflection classes wrapping the primitive types
  (<classname>java.lang.Integer</classname>,
  <classname>java.lang.Double</classname>, etc), or
  strings (otherwise an exception will emerge at compile-time). This is
  because only these types of objects can be stored in the Java class
  files directly. Also, it is responsibility of the caller to ensure
  that JEL namespace contains <function>getXXXProperty</function> methods
  with all the necessary argument types, corresponding to the translations
  defined in <classname>DVMap</classname>. For identity translations only
  <function>getXXXProperty</function> methods accepting strings are
  necessary.</para>
</section>
<section>
  <title id="OBJCASTS">Objects down-casting.</title>
  <para>The <parameter>cnmap</parameter> argument of 
  <classname>gnu.jel.Library</classname> constructor,
  allows to enable the non-primitive type casts in JEL compiled
  expressions. If <constant>cnmap!=null</constant> it must be
  <classname>java.util.Hashtable</classname> with 
  <classname>java.lang.Class</classname> objects as
  elements and <classname>java.lang.String</classname> objects as keys.
  When the object cast 
  <userinput>&quot;(non_primitive_type_name)&nbsp;var&quot;</userinput> is
  encountered in the expression, &quot;the non_primitive_type_name&quot;
  string is looked in the <parameter>cnmap</parameter> hashtable and the 
  cast to the corresponding class is generated by JEL. The absence of the
  name in the hashtable produces the compile-time error. It is possible for
  keys in <parameter>cnmap</parameter> to contain &quot;.&quot; (dot) symbols
  in them.</para>
</section>
</chapter>
<chapter>
  <title id="UNWRAP">Automatic unwrapping of objects to primitive
  types.</title>
  <para>This problem appears mostly when one uses dynamic variables, but may
  also arise in other cases. Suppose a reference to the object of the
  class <classname>Weight</classname> (representing a weight of a certain item)
  appeared in the expression. It is clear that 
  <classname>Weight</classname> is always represented by a floating point
  number (although it may have other properties, like units). If the 
  class <classname>Weight</classname> has the method
  <programlisting>public double getValue()</programlisting>
  the value of weight can be accessed in expressions using syntax
  <constant>w.getValue()</constant>, supposing the variable
  <varname>w</varname> has type <classname>Weight</classname>.</para>

  <para>To save typing (since version 0.9.3 of JEL) one may have the class
  <classname>Weight</classname> implement
  <classname>gnu.jel.reflect.Double</classname> interface. Then,
  the aforementioned getValue method will be called automatically by JEL
  (or object <varname>w</varname> will be &quot;unwrapped&quot; to 
  primitive type). This
  unwrapping will be performed automatically when needed: one can have
  expressions <userinput>"w+1.0"</userinput> meaning 
  <userinput>"w.getValue()+1"</userinput> and 
  <userinput>"w.getUnits()"</userinput> both
  valid (in the second case <varname>w</varname> 
  is not &quot;unwrapped&quot;). </para>

  <para>There are <classname>gnu.jel.reflect.*</classname> interfaces
  for all Java primitive types. To use the automatic unwrapping one
  just needs to make his classes to implement one of these interfaces.</para>
  
  <para>There is a similar mechanism for strings (since version 0.9.6)
  and a corresponding empty interface 
  <classname>gnu.jel.reflect.String</classname>
  to denote objects automatically convertible to
  <classname>java.lang.String</classname> by means of their 
  <function>.toString()</function> method. For
  example, if <varname>x</varname> is of a class implementing
  <classname>gnu.jel.reflect.String</classname> interface the expression
  <userinput>x+&quot;a&quot;</userinput> will be compiled into
  <userinput>x.toString()+&quot;a&quot;</userinput> (otherwise this expression
  produces a error message). The objects automatically convertible to
  strings can also be supplied as arguments of methods requiring
  <classname>java.lang.String</classname> (usual method overloading rules
  apply). Still, in the current version of JEL it is impossible to
  cast methods of <classname>java.lang.String</classname> on such objects.
  That is <userinput>x.substring(1)</userinput> is a syntax error 
  (unless <varname>x</varname>> itself
  has the <function>.substring(int)</function> method). This deficiency can be
  addressed in future.</para>
</chapter>
<chapter>
  <title id="ERRORS">Error detection and reporting</title>
  <para>Expressions are made by human, and making errors is the
  natural property of humans, consequently, JEL has to be aware of
  that.</para>
  <para>There are two places, where errors can appear. First are the
  compilation errors, which are thrown in the form of
  <classname>gnu.jel.CompilationException</classname> by the
  <function>gnu.jel.Evaluator.compile</function>. These errors signal about
  syntax problems in the entered expressions, wrong function names,
  illegal <emphasis>types</emphasis> combinations, but NOT about illegal
  values of arguments of functions. The second source of errors is the
  compiled code itself, Throwables, thrown out of
  <function>gnu.jel.CompiledExpression.evaluate</function> are primarily due to
  the invalid <emphasis>values</emphasis> of function arguments.</para>
  <para>Compilation errors are easy to process. Normally, you should
  surround compilation by the 
  <programlisting>   try {
      // ... compilation
   catch (CompilationException e) {
      // ... process and report the error
   }</programlisting>
   block. Caught <classname>gnu.jel.CompilationException</classname> can be
   interrogated, then, on the subject of WHERE error has occurred
   (<function>getCol</function>) and WHAT was the
   error (<function>getMessage</function>). This
   information should then be presented to user. It is wise to use
   information about error column to position the cursor automatically
   to the erroneous place in the expression.</para>
   <para>Errors of the second type are appearing during the function
   evaluation and can not be so nicely dealt with by JEL. They depend
   on the actual library, supplied to the compiler. For example
   methods of <classname>java.lang.Math</classname> do not generate any checked
   exceptions at all (still, Errors are possible), but you may connect
   library, of functions throwing exceptions. As a general rule :
   <emphasis>exceptions thrown by functions from the library are thrown from
   <function>evaluate</function> method</emphasis></para>
</chapter>
<chapter>
   <title id="FASTER">Making things faster</title>
   <para>In the above text the result of the computation, returned by
   <function>evaluate</function> was always an object. While this is
   very flexible it is not very fast. Objects have to be allocated on
   heap and garbage collected. When the result of computation is the
   Java primitive type it can be desirable to retrieve it without
   creation of the object. This can be done (since the version 0.2 of
   JEL) with <function>evaluateXX()</function> family of calls (see
   <classname>gnu.jel.CompiledExpression</classname>. There is an
   <function>evaluateXX()</function> method for each Java primitive
   type, if you know what type expression has you can just call the
   corresponding method.</para>
   <para>If you do not know the type of the compiled expression you can
   query it using <function>getType</function>. Be warned, that the
   call to wrong <function>evaluateXX</function> method will result in
   exception. Another tricky point is that JEL always selects smallest
   data type for constant representation. Namely, expression
   <userinput>"1"</userinput> has type 
   <type>byte</type> and not <type>int</type>, thus in
   most cases you will have to query the type, and only then, call the
   proper <function>evaluateXX</function> method.</para>
   <para>It is anyway possible to eliminate type checks at evaluation
   time completely. There is a version of
   <function>compile</function> method in 
   <classname>gnu.jel.Evaluator</classname>, which allows to fix
   the type of the result. It directs the compiler to perform the
   widening conversion to the given type, before returning the
   result. For example: if you fix the type to be <type>int</type>
   (passing <classname>java.lang.Integer.TYPE</classname> as an 
   argument to compile) all expressions (such as 
   <userinput>"1"</userinput>, <userinput>"2+5"</userinput>,
   <userinput>"2*2"</userinput>) will be evaluated by 
   <function>evaluate_int</function> method of
   the compiled expression. Also, the attempt to evaluate
   <userinput>"1+2L"</userinput> will be rejected by compiler, 
   asking to insert the explicit narrowing conversion (such as
   <userinput>"(int)(1+2L)"</userinput>).</para>
</chapter>
<chapter>
  <title id="SERIALIZATION">Serialization of compiled expressions</title>
  <para>There used to be a specialized serialization interface in JEL up
  to version 0.8.3. The need for such interface was dictated by the fact
  that JEL allowed to use constants of arbitrary reference types in
  expressions, which is not supported directly by the Java class file
  format. Starting with version 0.9 this feature was removed and now JEL
  generates ordinary Java class files.</para>
  <para>To store compiled expressions into a file just grab their code with
  <function>gnu.jel.Evaluator.compileBits</function>. The code is returned as a
  byte array which is easy to save/restore. Then, the expression can be
  instantiated using <classname>gnu.jel.ImageLoader</classname> with the code
  <programlisting>byte[] image; 
// ... code to read the JEL-generated class file into the &quot;image&quot; ...
CompiledExpression expression=(CompiledExpression)(ImageLoader.load(image)).newInstance();</programlisting>
  or, alternatively, by compiling your source against generated
  class file. Note that in this version of JEL all generated classes
  have the name &quot;dump&quot; and are in the root package. If there
  will be such need in future the Evaluator interface can be extended to
  assign user-supplied names for new expressions.</para>
</chapter>
<chapter>
  <title id="LIMITATIONS">Limitations of JEL</title>
  <para>There is one serious limitation, which should be
  mentioned. Actually it is not a JEL limitation but rather a limitation
  of the typical Java run-time</para>
  <para>To load compiled expressions into the Java virtual machine memory
  JEL uses a custom <classname>java.lang.ClassLoader</classname>. While there
  is nothing wrong with that, setting up a classLoader is a privileged
  operation in Java. This means either JEL should run in a Java
  <emphasis>application</emphasis> (there are no security restrictions on Java
  applications), or , if JEL is distributed in some custom
  <emphasis>applet</emphasis> the applet should be
  <emphasis>signed</emphasis>.</para>
</chapter>
<chapter>
  <title id="SUMMARY">Summarizing remarks</title>
  <para> I hope you found JEL useful.  Don't hesitate to contact me if
  there are any problems with JEL, please, report BUGS, suggest tests,
  send me your patches,... There are still many improvements to be
  done.</para>
  
  <para>Most current information about JEL should be available at 
  <ulink url="http://galaxy.fzu.cz/JEL/">http://galaxy.fzu.cz/JEL/</ulink>.</para>
  
  <para>JEL is the &quot;free software&quot; and is distributed to you
  under terms of GNU General Public License. Find the precise terms of
  the license in the file ./COPYING in the root of this distribution.</para>

  <para>Please, contact the author directly if you'd like JEL to be
  commercially licensed to you on a different terms.</para>
</chapter>
</book>